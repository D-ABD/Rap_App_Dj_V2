from datetime import date
from typing import Optional, Dict, Any

from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils.timezone import localdate

from .base import BaseModel
from .centres import Centre


# -------------------------------------------------------------------
# ğŸ“Š ACTIVITÃ‰S DÃ‰CLIC : donnÃ©es rÃ©elles (sÃ©ances, effectifs)
# -------------------------------------------------------------------
class Declic(BaseModel):
    """
    ActivitÃ© DÃ©clic : Information collective ou sessions thÃ©matiques.

    - Pour les informations collectives :
      * nombre_places_ouvertes : places disponibles pour les prescripteurs
      * nombre_prescriptions   : candidats envoyÃ©s par les prescripteurs
      * nb_presents_info       : candidats prÃ©sents Ã  la sÃ©ance
      * nb_absents_info        : candidats absents Ã  la sÃ©ance
      * nb_adhesions           : candidats qui adhÃ¨rent au dispositif

    - Pour les sessions DÃ©clic :
      * nb_inscrits_declic     : participants inscrits
      * nb_presents_declic     : prÃ©sents Ã  la session
      * nb_absents_declic      : absents Ã  la session
    """

    class TypeDeclic(models.TextChoices):
        INFO_COLLECTIVE = "info_collective", _("Information collective")
        SESSION1 = "session_1", _("Session 1")
        SESSION2 = "session_2", _("Session 2")
        SESSION3 = "session_3", _("Session 3")
        SESSION4 = "session_4", _("Session 4")
        SESSION5 = "session_5", _("Session 5")
        SESSION6 = "session_6", _("Session 6")
        AUTRE = "autre", _("Autre activitÃ© DÃ©clic")

    type_declic = models.CharField(max_length=40, choices=TypeDeclic.choices, verbose_name=_("Type dâ€™activitÃ©"))
    date_declic = models.DateField(_("Date"), help_text=_("Date de la sÃ©ance ou de la semaine concernÃ©e"))

    centre = models.ForeignKey(
        Centre,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="declics",
        verbose_name=_("Centre de formation"),
    )

    # --- DonnÃ©es Information Collective ---
    nombre_places_ouvertes = models.PositiveIntegerField(default=0, verbose_name=_("Places ouvertes (IC)"))
    nombre_prescriptions = models.PositiveIntegerField(default=0, verbose_name=_("Prescriptions (IC)"))
    nb_presents_info = models.PositiveIntegerField(default=0, verbose_name=_("PrÃ©sents (IC)"))
    nb_absents_info = models.PositiveIntegerField(default=0, verbose_name=_("Absents (IC)"))
    nb_adhesions = models.PositiveIntegerField(default=0, verbose_name=_("AdhÃ©sions (IC)"))

    # --- DonnÃ©es Sessions DÃ©clic ---
    nb_inscrits_declic = models.PositiveIntegerField(default=0, verbose_name=_("Inscrits (DÃ©clic)"))
    nb_presents_declic = models.PositiveIntegerField(default=0, verbose_name=_("PrÃ©sents (DÃ©clic)"))
    nb_absents_declic = models.PositiveIntegerField(default=0, verbose_name=_("Absents (DÃ©clic)"))

    commentaire = models.TextField(blank=True, null=True, verbose_name=_("Commentaire / notes"))

    class Meta:
        verbose_name = _("SÃ©ance DÃ©clic")
        verbose_name_plural = _("SÃ©ances DÃ©clic")
        ordering = ["-date_declic", "-id"]
        indexes = [
            models.Index(fields=["centre"]),
            models.Index(fields=["date_declic"]),
            models.Index(fields=["type_declic"]),
        ]

    def __str__(self):
        return f"{self.get_type_declic_display()} â€“ {self.date_declic:%d/%m/%Y}"

    # -------------------------------------------------------------------
    # ğŸ”„ Sauvegarde automatique
    # -------------------------------------------------------------------
    def save(self, *args, user=None, **kwargs):
        """Met automatiquement Ã  jour les absents et renseigne created_by / updated_by."""
        self.nb_absents_declic = max(0, self.nb_inscrits_declic - self.nb_presents_declic)
        self.nb_absents_info = max(0, self.nombre_prescriptions - self.nb_presents_info)

        if user and not self.pk:
            self.created_by = user
        if user:
            self.updated_by = user

        super().save(*args, **kwargs)

    # -------------------------------------------------------------------
    # ğŸ“ˆ Taux pour Information collective
    # -------------------------------------------------------------------
    @property
    def taux_prescription(self):
        return round((self.nombre_prescriptions / self.nombre_places_ouvertes) * 100, 1) if self.nombre_places_ouvertes else 0

    @property
    def taux_presence_info(self):
        return round((self.nb_presents_info / self.nombre_prescriptions) * 100, 1) if self.nombre_prescriptions else 0

    @property
    def taux_adhesion(self):
        return round((self.nb_adhesions / self.nb_presents_info) * 100, 1) if self.nb_presents_info else 0

    # -------------------------------------------------------------------
    # ğŸ“Š Taux pour sessions DÃ©clic
    # -------------------------------------------------------------------
    @property
    def taux_presence_declic(self):
        return round((self.nb_presents_declic / self.nb_inscrits_declic) * 100, 1) if self.nb_inscrits_declic else 0

    # -------------------------------------------------------------------
    # ğŸ¯ Objectifs dynamiques (annuels)
    # -------------------------------------------------------------------
    @property
    def objectif_annuel(self):
        return ObjectifDeclic.get_objectif(self.centre, self.date_declic)

    @property
    def taux_atteinte_annuel(self):
        if not self.objectif_annuel or not self.centre:
            return 0
        cumul_annuel = (
            Declic.objects.filter(
                centre=self.centre,
                date_declic__year=self.date_declic.year,
                type_declic=self.TypeDeclic.INFO_COLLECTIVE,
            ).aggregate(total=models.Sum("nb_presents_info"))["total"]
            or 0
        )
        return round((cumul_annuel / self.objectif_annuel) * 100, 1)

    @property
    def reste_a_faire(self):
        if not self.objectif_annuel or not self.centre:
            return 0
        cumul_annuel = (
            Declic.objects.filter(
                centre=self.centre,
                date_declic__year=self.date_declic.year,
                type_declic=self.TypeDeclic.INFO_COLLECTIVE,
            ).aggregate(total=models.Sum("nb_presents_info"))["total"]
            or 0
        )
        return max(self.objectif_annuel - cumul_annuel, 0)

    # -------------------------------------------------------------------
    # ğŸ“‰ RÃ©tention de parcours (Session1 â†’ Session6)
    # -------------------------------------------------------------------
    @classmethod
    def taux_retention(cls, centre, annee):
        debut = (
            cls.objects.filter(centre=centre, type_declic=cls.TypeDeclic.SESSION1, date_declic__year=annee)
            .aggregate(total=models.Sum("nb_presents_declic"))["total"]
            or 0
        )
        fin = (
            cls.objects.filter(centre=centre, type_declic=cls.TypeDeclic.SESSION6, date_declic__year=annee)
            .aggregate(total=models.Sum("nb_presents_declic"))["total"]
            or 0
        )
        return round((fin / debut) * 100, 1) if debut else 0

    # -------------------------------------------------------------------
    # ğŸ‘¥ Totaux dâ€™accueillis (prÃ©sents)
    # -------------------------------------------------------------------
    @classmethod
    def total_accueillis(cls, annee: Optional[int] = None, centre=None, departement=None, type_declic=None) -> int:
        today = localdate()
        annee = annee or today.year
        qs = cls.objects.filter(date_declic__year=annee)

        if centre:
            qs = qs.filter(centre=centre)
        if departement:
            qs = [d for d in qs if d.centre and d.centre.departement == departement]

            if type_declic == cls.TypeDeclic.INFO_COLLECTIVE:
                total = sum(d.nb_presents_info for d in qs)
            elif type_declic and type_declic.startswith("session"):
                total = sum(d.nb_presents_declic for d in qs)
            else:
                total = sum((d.nb_presents_info + d.nb_presents_declic) for d in qs)
            return total

        if type_declic == cls.TypeDeclic.INFO_COLLECTIVE:
            total = qs.aggregate(total=models.Sum("nb_presents_info"))["total"] or 0
        elif type_declic and type_declic.startswith("session"):
            total = qs.aggregate(total=models.Sum("nb_presents_declic"))["total"] or 0
        else:
            total_ic = qs.aggregate(total=models.Sum("nb_presents_info"))["total"] or 0
            total_declic = qs.aggregate(total=models.Sum("nb_presents_declic"))["total"] or 0
            total = total_ic + total_declic

        return total

    @classmethod
    def accueillis_par_centre(cls, annee: Optional[int] = None, type_declic=None) -> Dict[str, int]:
        annee = annee or localdate().year
        data = {}
        for centre in Centre.objects.all():
            data[getattr(centre, "nom", str(centre))] = cls.total_accueillis(annee=annee, centre=centre, type_declic=type_declic)
        return data

    @classmethod
    def accueillis_par_departement(cls, annee: Optional[int] = None, type_declic=None) -> Dict[str, int]:
        annee = annee or localdate().year
        data = {}
        for centre in Centre.objects.all():
            dep = getattr(centre, "departement", None)
            if not dep:
                continue
            total = cls.total_accueillis(annee=annee, departement=dep, type_declic=type_declic)
            data[dep] = data.get(dep, 0) + total
        return dict(sorted(data.items()))

    # -------------------------------------------------------------------
    # ğŸ¯ Reste Ã  faire
    # -------------------------------------------------------------------
    @classmethod
    def reste_a_faire_centre(cls, annee: Optional[int] = None) -> Dict[str, int]:
        annee = annee or localdate().year
        data = {}
        for obj in ObjectifDeclic.objects.filter(annee=annee):
            realise = cls.total_accueillis(annee=annee, centre=obj.centre, type_declic=cls.TypeDeclic.INFO_COLLECTIVE)
            reste = max(obj.valeur_objectif - realise, 0)
            data[getattr(obj.centre, "nom", str(obj.centre))] = reste
        return data

    @classmethod
    def reste_a_faire_departement(cls, annee: Optional[int] = None) -> Dict[str, int]:
        annee = annee or localdate().year
        data: Dict[str, int] = {}
        for obj in ObjectifDeclic.objects.filter(annee=annee).select_related("centre"):
            dep = getattr(obj.centre, "departement", None)
            if not dep:
                continue
            realise_dep = cls.total_accueillis(
                annee=annee,
                departement=dep,
                type_declic=cls.TypeDeclic.INFO_COLLECTIVE,
            )
            if dep not in data:
                data[dep] = 0
            data[dep] += max(obj.valeur_objectif - realise_dep, 0)
        return dict(sorted(data.items()))

    @classmethod
    def reste_a_faire_total(cls, annee: Optional[int] = None) -> int:
        annee = annee or localdate().year
        objectif_total = ObjectifDeclic.objects.filter(annee=annee).aggregate(total=models.Sum("valeur_objectif"))["total"] or 0
        realise_total = cls.total_accueillis(annee=annee, type_declic=cls.TypeDeclic.INFO_COLLECTIVE)
        return max(objectif_total - realise_total, 0)

    # -------------------------------------------------------------------
    # ğŸ§¾ SynthÃ¨se globale
    # -------------------------------------------------------------------
    @classmethod
    def synthese_objectifs(cls, annee: Optional[int] = None) -> Dict[str, Any]:
        annee = annee or localdate().year
        objectif_total = ObjectifDeclic.objects.filter(annee=annee).aggregate(total=models.Sum("valeur_objectif"))["total"] or 0
        realise_total = cls.total_accueillis(annee=annee, type_declic=cls.TypeDeclic.INFO_COLLECTIVE)
        taux_atteinte = round((realise_total / objectif_total) * 100, 1) if objectif_total else 0

        return {
            "annee": annee,
            "objectif_total": objectif_total,
            "realise_total": realise_total,
            "taux_atteinte_total": taux_atteinte,
            "reste_a_faire_total": max(objectif_total - realise_total, 0),
            "par_centre": cls.reste_a_faire_centre(annee),
            "par_departement": cls.reste_a_faire_departement(annee),
        }


# -------------------------------------------------------------------
# ğŸ¯ OBJECTIFS DÃ‰CLIC â€“ par centre (annuel)
# -------------------------------------------------------------------
class ObjectifDeclic(BaseModel):
    """Objectifs DÃ©clic : objectifs annuels par centre."""

    centre = models.ForeignKey(
        Centre,
        on_delete=models.CASCADE,
        related_name="objectifs_declic",
        verbose_name=_("Centre de formation"),
    )
    departement = models.CharField(max_length=3, blank=True, null=True, verbose_name=_("DÃ©partement"))
    annee = models.PositiveIntegerField(verbose_name=_("AnnÃ©e"))
    valeur_objectif = models.PositiveIntegerField(verbose_name=_("Objectif annuel (personnes)"))
    commentaire = models.TextField(blank=True, null=True)

    class Meta:
        verbose_name = _("Objectif DÃ©clic (centre)")
        verbose_name_plural = _("Objectifs DÃ©clic (centres)")
        ordering = ["-annee"]
        constraints = [models.UniqueConstraint(fields=["centre", "annee"], name="uniq_objectif_declic_centre_annee")]

    def __str__(self):
        base = str(self.centre)
        if self.departement:
            base += f" ({self.departement})"
        return f"{base} â€“ {self.annee}"

    # -------------------------------------------------------------------
    # ğŸ“Š DonnÃ©es agrÃ©gÃ©es
    # -------------------------------------------------------------------
    @property
    def data_declic(self) -> Dict[str, int]:
        if hasattr(self, "_data_declic_cache"):
            return self._data_declic_cache

        agg = (
            Declic.objects.filter(
                centre=self.centre,
                date_declic__year=self.annee,
                type_declic=Declic.TypeDeclic.INFO_COLLECTIVE,
            ).aggregate(
                total_places=models.Sum("nombre_places_ouvertes"),
                total_prescriptions=models.Sum("nombre_prescriptions"),
                total_presents=models.Sum("nb_presents_info"),
                total_adhesions=models.Sum("nb_adhesions"),
            )
            or {}
        )
        self._data_declic_cache = {
            "places": agg.get("total_places") or 0,
            "prescriptions": agg.get("total_prescriptions") or 0,
            "presents": agg.get("total_presents") or 0,
            "adhesions": agg.get("total_adhesions") or 0,
        }
        return self._data_declic_cache

    @property
    def taux_prescription(self):
        return round((self.data_declic["prescriptions"] / self.data_declic["places"]) * 100, 1) if self.data_declic["places"] else 0

    @property
    def taux_presence(self):
        return round((self.data_declic["presents"] / self.data_declic["prescriptions"]) * 100, 1) if self.data_declic["prescriptions"] else 0

    @property
    def taux_adhesion(self):
        return round((self.data_declic["adhesions"] / self.data_declic["presents"]) * 100, 1) if self.data_declic["presents"] else 0

    @property
    def taux_atteinte(self):
        return round((self.data_declic["presents"] / self.valeur_objectif) * 100, 1) if self.valeur_objectif else 0

    @property
    def reste_a_faire(self):
        return max(self.valeur_objectif - self.data_declic["presents"], 0)

    def synthese_globale(self) -> Dict[str, Any]:
        return {
            "centre": getattr(self.centre, "nom", str(self.centre)),
            "annee": self.annee,
            "objectif": self.valeur_objectif,
            "realise": self.data_declic["presents"],
            "adhesions": self.data_declic["adhesions"],
            "taux_prescription": self.taux_prescription,
            "taux_presence": self.taux_presence,
            "taux_adhesion": self.taux_adhesion,
            "taux_atteinte": self.taux_atteinte,
            "reste_a_faire": self.reste_a_faire,
        }

    @classmethod
    def get_objectif(cls, centre, date):
        if not centre or not date:
            return None
        return (
            cls.objects.filter(centre=centre, annee=date.year)
            .values_list("valeur_objectif", flat=True)
            .first()
        )

    def save(self, *args, user=None, **kwargs):
        if user and not self.pk:
            self.created_by = user
        if user:
            self.updated_by = user

        centre = getattr(self, "centre", None)
        if centre and not self.departement and getattr(centre, "departement", None):
            self.departement = centre.departement

        super().save(*args, **kwargs)
